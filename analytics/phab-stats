#!/usr/bin/env python

import os
import re
import argparse
import json
import phabricator
import requests
import pprint
import csv
from datetime import datetime
from datetime import timedelta

DATE_FORMAT = '%Y-%m-%d'

def parse_arguments():
    parser = argparse.ArgumentParser(description='Generate Scrum statistics on Phabricator workboard. See README.md for more.')
    parser.add_argument('--project-id', help='PHID of project')
    parser.add_argument('--task-counts', action='store_true', help='Ignore points, only use task counts')
    return parser.parse_args()

sprint_column_regex = r"^(\d\d\d\d-\d\d-\d\d) Sprint( \(.+\))?$"

def get_sprint_start_date(sprint_name):
    date_string = re.search(sprint_column_regex, sprint_name).group(1)
    return datetime.strptime(date_string, "%Y-%m-%d").date()

def get_sprint_end_date(sprint_name):
    return get_sprint_start_date(sprint_name) + timedelta(days=6)

def is_past_sprint(col):
    sprint_name = col['fields']['name']
    result = re.search(sprint_column_regex, sprint_name)
    if not result:
        return False
    end_date = get_sprint_end_date(sprint_name)
    today = datetime.now().date()
    return end_date < today

def get_velocity_data_for_project(phab, project_id):
    # result is dictionary like object with keys as task IDs and values as dictionary of task info
    result = phab.maniphest.query(projectPHIDs=[project_id], status="status-resolved")
    tasks = result.values()

    task_points = [float(task['points']) for task in tasks if task['points']]
    number_of_resolved_tasks_missing_estimate = len([task for task in tasks if not task['points']])

    individual_stats = {}

    for task in tasks:
        owner_id = task['ownerPHID']
        name = get_name_from_user_id(phab, owner_id)
        if not name in individual_stats:
            individual_stats[name] = {
                'points': 0.0,
                'tasks': 0,
                'tasks_missing_estimates': False
            }
        if task['points']:
            individual_stats[name]['points'] += float(task['points'])
        else:
            individual_stats[name]['tasks_missing_estimates'] = True
        individual_stats[name]['tasks'] += 1

    return {
        'number_of_resolved_tasks': len(tasks),
        'number_of_resolved_tasks_missing_estimate': number_of_resolved_tasks_missing_estimate,
        'points_of_resolved_tasks': sum(task_points),
        'individual_stats': individual_stats
    }

name_cache = {}

def get_name_from_user_id(phab, user_id):
    if user_id in name_cache:
        return name_cache[user_id]
    result = phab.user.search(constraints={"phids": [user_id]})
    name = result.data[0]['fields']['realName']
    name_cache[user_id] = name
    return name

def get_columns_from_project(phab, project_id):
    result = phab.project.column.search(constraints={"projects": [project_id]})

    sprint_columns = [{
        'start_date': get_sprint_start_date(col['fields']['name']),
        'last_date': get_sprint_end_date(col['fields']['name']),
        'column_project_id': col['fields']['proxyPHID'],
        'velocity': get_velocity_data_for_project(phab, col['fields']['proxyPHID'])
    } for col in result.data if is_past_sprint(col)]

    return sorted(sprint_columns, key=lambda col: col['start_date'])

def write_to_csv(sorted_sprints, filename, task_counts):
    task_points_word = 'Tasks' if task_counts else 'Points'
    contributor_columns = name_cache.values()
    with open(filename, 'wb') as csvfile:
        writer = csv.writer(csvfile, delimiter=',')
        writer.writerow(['Sprint Start Date', task_points_word + ' Resolved'] + contributor_columns + ([] if task_counts else ['Sprint has unestimated resolved tasks']))
        for sprint in sorted_sprints:
            total_count_or_points = sprint['velocity']['number_of_resolved_tasks'] if task_counts else sprint['velocity']['points_of_resolved_tasks']
            unestimated_resolved_tasks = sprint['velocity']['number_of_resolved_tasks_missing_estimate'] > 0
            contributor_points_or_tasks_resolved = [((name in sprint['velocity']['individual_stats'] and sprint['velocity']['individual_stats'][name][task_points_word.lower()]) or 0) for name in name_cache.values()]
            writer.writerow([sprint['start_date'], total_count_or_points] + contributor_points_or_tasks_resolved + ([] if task_counts else [unestimated_resolved_tasks]))

if __name__ == '__main__':
    args = parse_arguments()

    phab = phabricator.Phabricator(timeout=500)
    phab.update_interfaces()

    sorted_sprints = get_columns_from_project(phab, args.project_id)

    write_to_csv(sorted_sprints, 'output.csv', args.task_counts)
